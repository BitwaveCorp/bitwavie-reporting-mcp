/**
 * Query Executor Service
 * 
 * Handles executing SQL queries generated by the LLM,
 * including validation, error handling, and retry logic.
 */

import { BigQuery } from '@google-cloud/bigquery';
import { logFlow } from '../utils/logging.js';
import { QueryContextManager } from './query-context-manager.js';
import { LLMQueryTranslator } from './llm-query-translator.js';
import { ConnectionManager } from './connection-manager.js';

// Types
export interface ExecutionConfig {
  maxRetries?: number; // Default: 2
  timeoutMs?: number; // Default: 30000 (30 seconds)
  dryRun?: boolean; // Default: false (for validation without execution)
}

export interface ExecutionResult {
  success: boolean;
  data?: any[];
  error?: {
    message: string;
    code: string;
    sqlState?: string;
    details?: string;
  };
  metadata: {
    executionTimeMs: number;
    bytesProcessed?: number;
    rowCount?: number;
    retryCount: number;
    originalSql: string;
    finalSql: string;
  };
  // New fields for enhanced error handling
  explanation?: string;  // User-friendly explanation of the error
  suggestions?: string[]; // Suggested alternative prompts for the user
}

export interface ConnectionDetails {
  projectId?: string;
  datasetId?: string;
  tableId?: string;
  privateKey?: string;
  isConnected?: boolean;
  schemaType?: string;
}

export class QueryExecutor {
  private bigquery: BigQuery;
  private llmTranslator: LLMQueryTranslator;
  private queryContextManager: QueryContextManager | null = null;
  private config: ExecutionConfig = {
    maxRetries: 2,
    timeoutMs: 30000,
    dryRun: false
  };
  
  constructor(
    projectId: string,
    llmTranslator?: LLMQueryTranslator,
    config?: ExecutionConfig
  ) {
    // Initialize BigQuery client

    logFlow('WALKTHROUGH_SHOWTABLE7', 'INFO', 'Initializing BigQuery client', {
      projectId
    });

    
    this.bigquery = new BigQuery({
      projectId
    });
    
    // Set LLM translator if provided
    if (llmTranslator) {
      this.llmTranslator = llmTranslator;
    } else {
      // We should never reach here in practice as the translator should always be provided
      throw new Error('LLMQueryTranslator is required');
    }
    this.queryContextManager = new QueryContextManager(); 
    
    // Apply custom config if provided
    if (config) {
      this.config = { ...this.config, ...config };
    }
    
    logFlow('QUERY_EXECUTOR', 'INFO', 'Query Executor initialized', {
      projectId,
      hasLLMTranslator: !!this.llmTranslator,
      maxRetries: this.config.maxRetries,
      timeoutMs: this.config.timeoutMs,
      dryRun: this.config.dryRun
    });
  }
  
  /**
   * Execute a SQL query
   * @param sql The SQL query to execute
   * @param parameters Optional query parameters
   * @param connectionDetails Optional connection details
   * @param originalPrompt Optional original prompt used to generate the SQL
   * @param userQuery Optional user's original natural language query
   * @returns Execution result with data or error
   */
  public async executeQuery(
    sql: string,
    parameters?: Record<string, any>,
    connectionDetails?: ConnectionDetails,
    originalPrompt?: string,
    userQuery?: string
  ): Promise<ExecutionResult> {
    
    // Log the parameters for debugging
    logFlow('QUERY_EXECUTOR', 'INFO', 'Execute query parameters', {
      sqlLength: sql.length,
      hasParameters: !!parameters,
      hasConnectionDetails: !!connectionDetails,
      hasOriginalPrompt: !!originalPrompt,
      originalPromptLength: originalPrompt?.length || 0,
      hasUserQuery: !!userQuery,
      userQueryLength: userQuery?.length || 0,
      schemaType: connectionDetails?.schemaType || 'Not provided'
    });
    const startTime = Date.now();
    let retryCount = 0;
    let currentSql = sql;
    let error: any = null;
    
    logFlow('QUERY_EXECUTOR', 'ENTRY', 'Executing query', {
      sqlLength: sql.length,
      hasParameters: !!parameters,
      parameterCount: parameters ? Object.keys(parameters).length : 0,
      hasConnectionDetails: !!connectionDetails,
      connectionSource: connectionDetails ? 'session' : 'environment',
      hasOriginalPrompt: !!originalPrompt,
      hasUserQuery: !!userQuery
    });
    
    // First, validate the SQL
    try {
      await this.validateSql(currentSql);
    } catch (validationError: any) {
      // If validation fails and we have an LLM translator, try to correct the SQL
      if (this.llmTranslator && retryCount < (this.config.maxRetries || 2)) {
        logFlow('QUERY_EXECUTOR', 'INFO', 'Validation failed, attempting correction', {
          error: validationError.message,
          retryCount
        });
        
        // First, try to get context from SQL comment if available
        let contextId = this.queryContextManager?.extractContextIdFromSql(currentSql);
        let context = contextId ? this.queryContextManager?.getContext(contextId) : undefined;
        
        // If context is available, use it; otherwise fall back to parameters
        const contextPrompt = context?.originalPrompt || originalPrompt || '';
        const contextUserQuery = context?.userQuery || userQuery || '';
        
        // If we have the original prompt and user query (from either source), use enhanced error correction
        if (contextPrompt && contextUserQuery) {
          logFlow('QUERY_EXECUTOR', 'INFO', 'Using enhanced error correction', {
            source: context ? 'query_context' : 'parameters',
            hasContextId: !!contextId
          });
          try {
            const correction = await this.llmTranslator.correctSQLWithExplanation(
              contextPrompt,
              currentSql,
              validationError.message,
              contextUserQuery
            );
            
            // If we got a corrected SQL, try that
            if (correction.sql) {
              currentSql = correction.sql;
              retryCount++;
              
              // Validate the corrected SQL
              try {
                await this.validateSql(currentSql);
                
                // SQL is valid, continue execution with the corrected SQL
                logFlow('QUERY_EXECUTOR', 'INFO', 'Enhanced correction successful', {
                  originalLength: sql.length,
                  correctedLength: currentSql.length
                });
              } catch (secondValidationError: any) {
                // If validation still fails, return enhanced error info
                const executionTimeMs = Date.now() - startTime;
                
                logFlow('QUERY_EXECUTOR', 'ERROR', 'Validation failed after enhanced correction', {
                  error: secondValidationError.message,
                  executionTimeMs
                });
                
                return {
                  success: false,
                  error: this.formatError(secondValidationError),
                  metadata: {
                    executionTimeMs,
                    retryCount,
                    originalSql: sql,
                    finalSql: currentSql
                  },
                  explanation: correction.explanation,
                  suggestions: correction.suggestions
                };
              }
            } else {
              // If no corrected SQL but we have explanation, return that
              const executionTimeMs = Date.now() - startTime;
              
              logFlow('QUERY_EXECUTOR', 'ERROR', 'Enhanced correction provided no SQL', {
                error: validationError.message,
                executionTimeMs,
                hasExplanation: !!correction.explanation,
                suggestionCount: correction.suggestions?.length || 0
              });
              
              return {
                success: false,
                error: this.formatError(validationError),
                metadata: {
                  executionTimeMs,
                  retryCount,
                  originalSql: sql,
                  finalSql: currentSql
                },
                explanation: correction.explanation,
                suggestions: correction.suggestions
              };
            }
          } catch (correctionError) {
            // Fall back to simple correction if enhanced correction fails
            logFlow('QUERY_EXECUTOR', 'ERROR', 'Enhanced correction failed, falling back', {
              error: correctionError instanceof Error ? correctionError.message : String(correctionError)
            });
            
            // Fall back to simple correction
            const correctedSql = await this.llmTranslator.correctSQLError(
              currentSql,
              validationError.message
            );
            
            if (correctedSql) {
              currentSql = correctedSql;
              retryCount++;
              
              // Validate the corrected SQL
              try {
                await this.validateSql(currentSql);
              } catch (secondValidationError: any) {
                // If validation still fails, return the error
                const executionTimeMs = Date.now() - startTime;
                
                logFlow('QUERY_EXECUTOR', 'ERROR', 'Validation failed after fallback correction', {
                  error: secondValidationError.message,
                  executionTimeMs
                });
                
                return {
                  success: false,
                  error: this.formatError(secondValidationError),
                  metadata: {
                    executionTimeMs,
                    retryCount,
                    originalSql: sql,
                    finalSql: currentSql
                  }
                };
              }
            } else {
              // If correction failed, return the original validation error
              const executionTimeMs = Date.now() - startTime;
              
              logFlow('QUERY_EXECUTOR', 'ERROR', 'Fallback correction failed', {
                error: validationError.message,
                executionTimeMs
              });
              
              return {
                success: false,
                error: this.formatError(validationError),
                metadata: {
                  executionTimeMs,
                  retryCount,
                  originalSql: sql,
                  finalSql: currentSql
                }
              };
            }
          }
        } else {
          // Use the simple correction if we don't have original prompt and user query
          const correctedSql = await this.llmTranslator.correctSQLError(
            currentSql,
            validationError.message
          );
          
          if (correctedSql) {
            currentSql = correctedSql;
            retryCount++;
            
            // Validate the corrected SQL
            try {
              await this.validateSql(currentSql);
            } catch (secondValidationError: any) {
              // If validation still fails, return the error
              const executionTimeMs = Date.now() - startTime;
              
              logFlow('QUERY_EXECUTOR', 'ERROR', 'Validation failed after simple correction', {
                error: secondValidationError.message,
                executionTimeMs
              });
              
              return {
                success: false,
                error: this.formatError(secondValidationError),
                metadata: {
                  executionTimeMs,
                  retryCount,
                  originalSql: sql,
                  finalSql: currentSql
                }
              };
            }
          } else {
            // If correction failed, return the original validation error
            const executionTimeMs = Date.now() - startTime;
            
            logFlow('QUERY_EXECUTOR', 'ERROR', 'Simple correction failed', {
              error: validationError.message,
              executionTimeMs
            });
            
            return {
              success: false,
              error: this.formatError(validationError),
              metadata: {
                executionTimeMs,
                retryCount,
                originalSql: sql,
                finalSql: currentSql
              }
            };
          }
        }
      } else {
        // If we don't have an LLM translator or reached max retries, return the validation error
        const executionTimeMs = Date.now() - startTime;
        
        logFlow('QUERY_EXECUTOR', 'ERROR', 'Validation failed, no correction attempted', {
          error: validationError.message,
          executionTimeMs
        });
        
        return {
          success: false,
          error: this.formatError(validationError),
          metadata: {
            executionTimeMs,
            retryCount,
            originalSql: sql,
            finalSql: currentSql
          }
        };
      }
    }
    
    // If we're in dry run mode, return success after validation
    if (this.config.dryRun) {
      const executionTimeMs = Date.now() - startTime;
      
      logFlow('QUERY_EXECUTOR', 'EXIT', 'Dry run completed successfully', {
        executionTimeMs
      });
      
      return {
        success: true,
        metadata: {
          executionTimeMs,
          retryCount,
          originalSql: sql,
          finalSql: currentSql
        }
      };
    }
    
    // Execute the query with retry logic
    let result: any[] = [];
    let metadata: any = {};
    
    while (retryCount <= (this.config.maxRetries || 2)) {
      try {
        // If connection details are provided, create a temporary BigQuery client with those details
        let queryBigquery = this.bigquery;
        
        if (connectionDetails && connectionDetails.projectId) {
          logFlow('QUERY_EXECUTOR', 'INFO', 'Using session connection details for query execution', {
            projectId: connectionDetails.projectId,
            source: 'session'
          });
          
          // Create a temporary BigQuery client with the session project ID
          queryBigquery = new BigQuery({
            projectId: connectionDetails.projectId
          });
        } else {
          logFlow('QUERY_EXECUTOR', 'INFO', 'Using environment connection details for query execution', {
            source: 'environment'
          });
        }
        
        const options: any = {
          query: currentSql,
          location: 'US',
          dryRun: this.config.dryRun || false
        };
        
        // Only add params if defined
        if (parameters) {
          options.params = parameters;
        }
        
        // Only add timeout if defined
        if (this.config.timeoutMs) {
          options.jobTimeoutMs = this.config.timeoutMs;
        }
        
        // Execute query and handle response
        // Using any[] to avoid TypeScript errors with BigQuery's response format
        const response = await queryBigquery.query(options);
        
        // BigQuery returns results as first element in array
        const rows = response && Array.isArray(response) ? response[0] : [];
        // Metadata is the second element
        const queryMetadata = response && Array.isArray(response) && response.length > 1 ? response[1] : {};
        
        // Query succeeded, store results and metadata
        result = rows;
        metadata = queryMetadata;
        
        // Exit the retry loop
        break;
      } catch (queryError: any) {
        error = queryError;
        
        // If we have an LLM translator and haven't reached max retries, try to correct the SQL
        if (this.llmTranslator && retryCount < (this.config.maxRetries || 2)) {
          logFlow('QUERY_EXECUTOR', 'INFO', 'Query failed, attempting correction', {
            error: queryError.message,
            retryCount
          });
          
          const correctedSql = await this.llmTranslator.correctSQLError(
            currentSql,
            queryError.message
          );
          
          if (correctedSql) {
            currentSql = correctedSql;
            retryCount++;
            
            // Continue to next iteration to try the corrected SQL
            continue;
          }
        }
        
        // If we don't have an LLM translator, reached max retries, or correction failed,
        // break out of the retry loop and return the error
        break;
      }
    }
    
    const executionTimeMs = Date.now() - startTime;
    
    // If we have an error, return it
    if (error) {
      logFlow('QUERY_EXECUTOR', 'ERROR', 'Query execution failed', {
        error: error.message,
        retryCount,
        executionTimeMs
      });
      
      return {
        success: false,
        error: this.formatError(error),
        metadata: {
          executionTimeMs,
          retryCount,
          originalSql: sql,
          finalSql: currentSql
        }
      };
    }
    
    // Otherwise, return the successful result
    logFlow('QUERY_EXECUTOR', 'EXIT', 'Query execution completed successfully', {
      rowCount: result.length,
      bytesProcessed: metadata.totalBytesProcessed,
      executionTimeMs
    });
    
    return {
      success: true,
      data: result,
      metadata: {
        executionTimeMs,
        bytesProcessed: metadata.totalBytesProcessed,
        rowCount: result.length,
        retryCount,
        originalSql: sql,
        finalSql: currentSql
      }
    };
  }
  
  /**
   * Validate a SQL query without executing it
   * @param sql The SQL query to validate
   * @returns Promise that resolves if validation succeeds, rejects if it fails
   */
  private async validateSql(sql: string): Promise<void> {
    try {
      logFlow('QUERY_EXECUTOR', 'ENTRY', 'Validating SQL', {
        sqlLength: sql.length
      });
      
      // Use BigQuery's dry run feature to validate the SQL
      const options: any = {
        query: sql,
        dryRun: true
      };
      
      const [job] = await this.bigquery.createQueryJob(options);
      
      logFlow('QUERY_EXECUTOR', 'EXIT', 'SQL validation successful', {
        bytesProcessed: job.metadata.statistics.totalBytesProcessed
      });
    } catch (error: any) {
      logFlow('QUERY_EXECUTOR', 'ERROR', 'SQL validation failed', {
        error: error.message
      });
      
      throw error;
    }
  }
  
  /**
   * Format an error for consistent output
   * @param error The raw error object
   * @returns Formatted error object
   */
  private formatError(error: any): {
    message: string;
    code: string;
    sqlState?: string;
    details?: string;
  } {
    // Extract error details
    const message = error.message || 'Unknown error';
    const code = error.code || 'UNKNOWN';
    const sqlState = error.sqlState;
    const details = error.errors && error.errors.length > 0
      ? error.errors.map((e: any) => e.message).join('; ')
      : undefined;
    
    return {
      message,
      code,
      sqlState,
      details
    };
  }
  
  /**
   * Classify an error message to help with error handling
   * @param errorMessage The error message
   * @returns Classification of the error
   */
  public classifyError(errorMessage: string): {
    type: 'syntax' | 'permission' | 'timeout' | 'resource' | 'schema' | 'other';
    fixable: boolean;
  } {
    const lowerError = errorMessage.toLowerCase();
    
    // Syntax errors
    if (lowerError.includes('syntax error') || 
        lowerError.includes('parsing failed') ||
        lowerError.includes('invalid') ||
        lowerError.includes('expected')) {
      return { type: 'syntax', fixable: true };
    }
    
    // Permission errors
    if (lowerError.includes('permission') || 
        lowerError.includes('access denied') ||
        lowerError.includes('not authorized')) {
      return { type: 'permission', fixable: false };
    }
    
    // Timeout errors
    if (lowerError.includes('timeout') || 
        lowerError.includes('exceeded time limit')) {
      return { type: 'timeout', fixable: true };
    }
    
    // Resource errors
    if (lowerError.includes('quota') || 
        lowerError.includes('resource') ||
        lowerError.includes('limit exceeded')) {
      return { type: 'resource', fixable: false };
    }
    
    // Schema errors
    if (lowerError.includes('column') || 
        lowerError.includes('table') ||
        lowerError.includes('field') ||
        lowerError.includes('not found') ||
        lowerError.includes('undefined')) {
      return { type: 'schema', fixable: true };
    }
    
    // Other errors
    return { type: 'other', fixable: false };
  }
}
